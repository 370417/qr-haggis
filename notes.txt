Let's say, instead of factorial right away, we do a fixed base system:

We could represent a deck by a 42-digit number in base 42

34, 23, 4, 9, ...
point from encoding_value to real_value 
represent card_value to encoding_value
- 34, 40 numbers left
[0, 34) U (34, 41] 
represent 41 as 34,

Encode chart
[0, 1, 2, ..., 32, 33, 41, 35, ... 40]

- 41, use 34 to do encoding. 40 numbers left
n = 34 + (41 * (34 + (40 * ...)))
[0, 34) U (34, 41) U (41, 41) point to 40 from 


Encode chart
[0, 1, 2, ..., 32, 33, 40, 35, ... 39]


- 40, use 34 to do encoding.
n = 34 + (41 * (34 + (40 * (34 + ...))))



-----------------------------------------------
encode 37 as 37
encoded_value = 
n_42 = 37 + (42 * n_41)

from now on card value 41 will use 37 as its encode value (41 cards remaining, 0 - 40)

encode 15 as 15
n_41 = 15 + (41 * n_40)

from now on card value 40 will use 15 as its encode value

encode 41 as 37
n_40 = 34 + (40 * n_39)

from now on card value 39 will use 37 as its encode value

encode 1 as 1
n_39 = 1 + (39 * n_38)

from now on card value 38 will use 1 as its encode value

encode 2 as 2
n_38 = 2 + (38 * n_37)

from now on who ever has encode value as 37 now will use 2 as its encode value (37 cards remaining, 0 - 36)

encode A as B
n_37 = B + (37 * n_36)
.                         (n-1) + (n * ((n-1)! - 1))
.                         3 + (4 * (3! - 1)) = 23 = 4! - 1
.                         2 + (3 * 1) = 5
n_2 = b_2 + (2 * n_1)     1 + (2* 0) = 1

n_1 = 0?    

n_42 = b_42 + (42 * (b_41 + (41 * (b_40 + (40 * (... b_2 + 2 * (n_1))))))
range of n_42: [0, 42! -1]
41, 40, 39, ..., 1, 0

smaller example:
max_n_5 = b_5 + (5 * (b_4 + (4 * (b_3 + (3 * (b_2 + (2 * b_1)))))))
max_n_5 = 4 + (5 * (3 + (4 * (2 + (3 * (1 + (2 * 0))))))) == 119 == 5! - 1

---

How many bits if we store game as an array:

42 elements, each element needs to represent:
    location type: haggis, hand1, hand2, table(order), captured_by
    order is in the range: [0, 35] There's 36 playable cards, at least one card must be in a hand

We could store:
    1. order (0 if not on table): 6bits
    2. owner (0 for haggis/not captured, 1 for hand1 or captured_by_p1, 2 for ...) 2bits
    3. is_on_table: boolean 1bit

How many bits if we store game as a big number:
    log_2(42!/8!) for the order of the non-haggis cards < 155bits
    8 bits for hand sizes
    35 element array of 1.64765 or 2 bits (105 or 140 bits)
    Total: 303 or 268
